options {
    IGNORE_CASE = true;
    STATIC = false;
}

PARSER_BEGIN(Grammar)
package JavaCC; 
import APIServices.Node;

public class Grammar {}

PARSER_END(Grammar)

/* Scanner */

/* characters that i need to avoid */

SKIP : {
        " "
    |   "\t"
    |   "\r"
    |   "\f"
    |   "\n"
    |   < "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    |   <"#*" (~["*"])* "*" (~["*", "#"] (~["*"])* "*" | "*")* "#">
    //|   "#*": MULTILINE_COMMENT
}

/* comments that take more than one line */

<MULTILINE_COMMENT> SKIP:
{
    "*#" : DEFAULT
}

<MULTILINE_COMMENT> MORE:
{
    < ~[] >
}

/* Reserved words and symbols */

TOKEN: {
        <MOD: "%%" >
    |   <EQUALS: "==" >
    |   <NOT_EQUALS: "!=" >
    |   <GREATER_EQUALS: ">=" >
    |   <LESSER_EQUALS: "<=" >
    |   <ARROW: "=>" >
    |   <VALUE_ASIGNMENT: "=" >
    |   <OPENING_P: "(" >
    |   <CLOSING_P: ")" >
    |   <OPENING_B: "[" >
    |   <CLOSING_B: "]" >
    |   <OPENING_C: "{" >
    |   <CLOSING_C: "}" >
    |   <COMMA: "," >
    |   <SEMICOLON: ";" >
    |   <PLUS: "+" >
    |   <MINUS: "-" >
    |   <TIMES: "*" >
    |   <DIV: "/" >
    |   <POWER: "^" >
    |   <GREATER: ">" >
    |   <LESSER: "<" >
    |   <NOT: "!" >
    |   <AND: "&" >
    |   <OR: "|" >
    |   <TERNARY: "?" >
    |   <COLON: ":" >
    |   <IF_KEYWORD: "if" >
    |   <ELSE_KEYWORD: "else" >
    |   <SWITCH_KEYWORD: "switch" >
    |   <CASE_KEYWORD: "case" >
    |   <BREAK_KEYWORD: "break" >
    |   <WHILE_KEYWORD: "while" >
    |   <DO_KEYWORD: "do" >
    |   <FOR_KEYWORD: "for" >
    |   <IN_KEYWORD: "in" >
    |   <CONTINUE_KEYWORD: "continue" >
    |   <RETURN_KEYWORD: "return" >
    |   <FUNCTION_KEYWORD: "function" >
    |   <DEFAULT_KEYWORD: "default" >
    |   <NULL_VALUE: "null" >
    |   <FALSE_VALUE: "false" >
    |   <TRUE_VALUE: "true" >
}

/* tokens that need a regular expression */

TOKEN: {
        <#DIGIT: ["0"-"9"] >
    |   <FRACTIONAL_DIGITS: "." ( <DIGIT> )+ >
    |   <NUMBER_VALUE: ( <DIGIT> )+ | ( <DIGIT> )+ <FRACTIONAL_DIGITS> >
    |   <STRING_VALUE: "\"" (~["\""])* "\"" >
    |   <#LETTER: ["a" - "z", "A" - "Z", "ñ", "Ñ"] >
    |   <IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> | "." | "_")* | "." (( <LETTER> | "." | "_" ) ( <LETTER> | "." | "_" | <DIGIT> )*)? >
}

/* Scanner End */

Node Root() :
{ Node root = new Node("root"); Node sentences = new Node("sentences"); Node aux; }
{
        ( aux = Sentence() { sentences.addChildren(aux); } )* <EOF> { root.addChildren(sentences); return root; }
}


Node Sentences_Block() : 
{ Node instruction; Node sentences = new Node("sentences"); }
{
    <OPENING_C> ( instruction = Sentence() { sentences.addChildren(instruction); } )* <CLOSING_C> { return sentences; }
}


Node Sentence() :
{ Node instruction; }
{
        instruction = Asignment() ( <SEMICOLON> )? { return instruction; }
    |
        instruction = If() { return instruction; }
    |
        instruction = Switch() { return instruction; }
    |
        instruction = While() { return instruction; }
    |
        instruction = Do_While() { return instruction; }
}

Node First_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Third_Expression() exp = PFirst_Expression(exp1)
    { return exp; }
}

Node PFirst_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <VALUE_ASIGNMENT> exp1 = Third_Expression() { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("=", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PFirst_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Third_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Fourth_Expression() exp = PThird_Expression(exp1)
    { return exp; }
}

Node PThird_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <OR> exp1 = Fourth_Expression()     { 
                                                bin = new Node("binary expression");
                                                op = new Node("|", v.beginLine, v.beginColumn, null);
                                                op.addChildren(inherited);
                                            }   res = PThird_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Fourth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Fifth_Expression() exp = PFourth_Expression(exp1)
    { return exp; }
}

Node PFourth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <AND> exp1 = Fifth_Expression() { 
                                            bin = new Node("binary expression");
                                            op = new Node("&", v.beginLine, v.beginColumn, null);
                                            op.addChildren(inherited);
                                        }   res = PFourth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Fifth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Sixth_Expression() exp = PFifth_Expression(exp1)
    { return exp; }
}

Node PFifth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <EQUALS> exp1 = Sixth_Expression()  { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("==", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PFifth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <NOT_EQUALS> exp1 = Sixth_Expression()  { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("!=", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PFifth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Sixth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Seventh_Expression() exp = PSixth_Expression(exp1)
    { return exp; }
}

Node PSixth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <LESSER> exp1 = Seventh_Expression()    { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("<", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <GREATER> exp1 = Seventh_Expression()   { 
                                                        bin = new Node("binary expression");
                                                        op = new Node(">", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <LESSER_EQUALS> exp1 = Seventh_Expression()     { 
                                                                bin = new Node("binary expression");
                                                                op = new Node("<=", v.beginLine, v.beginColumn, null);
                                                                op.addChildren(inherited);
                                                            }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <GREATER_EQUALS> exp1 = Seventh_Expression()    { 
                                                                bin = new Node("binary expression");
                                                                op = new Node(">=", v.beginLine, v.beginColumn, null);
                                                                op.addChildren(inherited);
                                                            }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Seventh_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Eigth_Expression() exp = PSeventh_Expression(exp1)
    { return exp; }
}

Node PSeventh_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <PLUS> exp1 = Eigth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("+", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PSeventh_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <MINUS> exp1 = Eigth_Expression()       { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("-", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSeventh_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Eigth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Nineth_Expression() exp = PEigth_Expression(exp1)
    { return exp; }
}

Node PEigth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <TIMES> exp1 = Nineth_Expression()  { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("*", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <DIV> exp1 = Nineth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("/", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <MOD> exp1 = Nineth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("%%", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}



Node Nineth_Expression() :
{ Node res; Node min; Token t; Node exp; }
{
        t = <MINUS> exp = Nineth_Expression()   {   
                                                    res = new Node("unary expression");
                                                    min = new Node("-", t.beginLine, t.beginColumn, null); 
                                                    min.addChildren(exp);
                                                    res.addChildren(min);
                                                    return res;
                                                }
    |
        t = <NOT> exp = Nineth_Expression()     {   
                                                    res = new Node("unary expression");
                                                    min = new Node("!", t.beginLine, t.beginColumn, null); 
                                                    min.addChildren(exp);
                                                    res.addChildren(min);
                                                    return res;
                                                }
    |
        res = Value() { return res; }
}

Node Value() :
{ Node aux; Token tok; }
{
        tok = <NULL_VALUE>                                          { return new Node("null value", tok.beginLine, tok.beginColumn, null); }
    |
        tok = <FALSE_VALUE>                                         { return new Node("bool value", tok.beginLine, tok.beginColumn, false); }
    | 
        tok = <TRUE_VALUE>                                          { return new Node("bool value", tok.beginLine, tok.beginColumn, true); }
    |
        tok = <NUMBER_VALUE>                                        { return new Node("number value", tok.beginLine, tok.beginColumn, Double.parseDouble(tok.image)); }
    |
        tok = <STRING_VALUE>                                        { return new Node("string value", tok.beginLine, tok.beginColumn, tok.image); }
    |
        tok = <IDENTIFIER>                                          { return new Node("identifier", tok.beginLine, tok.beginColumn, tok.image); }
    |
        <OPENING_P> aux = First_Expression() <CLOSING_P>            { return aux; }
}

Node Asignment() : 
{ Node previous; Token id; Token v;}
{
    id = <IDENTIFIER> v = <VALUE_ASIGNMENT> previous = Asignment_Options()  {   
                                                                                Node identifier = new Node("identifier", id.beginLine, id.beginColumn, id.image);
                                                                                previous.addChildrenAt(0, identifier);
                                                                                previous.setRow(v.beginLine);
                                                                                previous.setColumn(v.beginColumn);
                                                                                return previous; 
                                                                            }
}

Node Asignment_Options() :
{ Node exp; Node param = null; Node params = null; Node sent; boolean flag = false; }
{
        LOOKAHEAD(4) 
        <OPENING_P> ( param = Parameter() { flag = true; })? 
        <CLOSING_P> <ARROW> sent = Sentences_Block()                            { 
                                                                                    Node res = new Node("asignment");
                                                                                    Node arr = new Node("arrow def");
                                                                                    if (flag) {
                                                                                        params = new Node("parameters");
                                                                                        params.addChildren(param);
                                                                                        arr.addChildren(params);
                                                                                    }
                                                                                    arr.addChildren(sent);
                                                                                    res.addChildren(arr);
                                                                                    return res;
                                                                                }
    |
        LOOKAHEAD(3)
        <OPENING_P> param = Parameter() <COMMA>
        params = Parameters_List() <CLOSING_P> 
        <ARROW> sent = Sentences_Block()                                        {
                                                                                    Node res = new Node("arrow function");
                                                                                    Node arr = new Node("arrow def");
                                                                                    params.addChildrenAt(0, param);
                                                                                    arr.addChildren(params);
                                                                                    arr.addChildren(sent);
                                                                                    res.addChildren(arr);
                                                                                    return res;
                                                                                }
    |
        <FUNCTION_KEYWORD> <OPENING_P>
        ( params = Parameters_List() )? 
        <CLOSING_P> sent = Sentences_Block()                                    {
                                                                                    Node res = new Node("function");
                                                                                    if (params != null) 
                                                                                        res.addChildren(params);
                                                                                    res.addChildren(sent);
                                                                                    return res;
                                                                                }
    |
        exp = First_Expression()                                                { 
                                                                                    res = new Node("asignment");
                                                                                    res.addChildren(exp);
                                                                                    return res;
                                                                                }
}



Node Parameters_List() : 
{ Node params = new Node("parameters"); Node aux;}
{
    aux = Parameter() { params.addChildren(aux); } ( <COMMA> aux = Parameter() { params.addChildren(aux); } )* { return params;}            
}

Node Parameter() : 
{ Token tok; Node res; Node id; Node exp = null; boolean flag = false;}
{
        tok = <IDENTIFIER> ( <VALUE_ASIGNMENT> exp = First_Expression() { flag = true; } )? 
        { 
            if (!flag) {
                return new Node("identifier", tok.beginLine, tok.beginColumn, tok.image); 
            }
            else {
                res = new Node("asignment");
                id = new Node("identifier", tok.beginLine, tok.beginColumn, tok.image);
                res.addChildren(id);
                res.addChildren(exp);
                return res;
            }
        }
}

Node If() :
{ Token i; Node elseNode = null; boolean flag = false; Node sentences; Node condition; }
{
    i = <IF_KEYWORD> <OPENING_P> condition = First_Expression()
    <CLOSING_P> sentences = Sentences_Block()
    ( elseNode = Else() { flag = true; } )?                         { 
                                                                        Node ifNode = new Node("if sentence", i.beginLine, i.beginColumn, null);
                                                                        Node cond = new Node("condition");
                                                                        cond.addChildren(condition);
                                                                        ifNode.addChildren(cond);
                                                                        ifNode.addChildren(sentences);
                                                                        if (flag) 
                                                                            ifNode.addChildren(elseNode);
                                                                        return ifNode;
                                                                    }
}

Node Else() :
{ Token e; Node ifNode = null; Node sentences = null;}
{
        LOOKAHEAD(2)
        e = <ELSE_KEYWORD> sentences = Sentences_Block()            { 
                                                                        Node elseNode = new Node("else sentence", e.beginLine, e.beginColumn, null); 
                                                                        elseNode.addChildren(sentences);
                                                                        return elseNode;
                                                                    }
    |
        LOOKAHEAD(1)
        e = <ELSE_KEYWORD> ifNode = If()                            {
                                                                        Node elseNode = new Node("else sentence", e.beginLine, e.beginColumn, null);
                                                                        for (Node child : ifNode.getChildren()) 
                                                                            elseNode.addChildren(child);
                                                                        return elseNode;
                                                                    }
}

Node Switch() : 
{Token s; Node val; Node body; }
{
    s = <SWITCH_KEYWORD> <OPENING_P> val = First_Expression()
    <CLOSING_P> <OPENING_C> body = Switch_Body() <CLOSING_C>                    {
                                                                                    Node switchNode = new Node("switch sentence", s.beginLine, s.beginColumn, null);
                                                                                    Node condition = new Node("condition");
                                                                                    condition.addChildren(val);
                                                                                    switchNode.addChildren(condition);
                                                                                    switchNode.addChildren(body);
                                                                                    return switchNode;
                                                                                }
}

Node Switch_Body() : 
{ Node cases; Node def = null; boolean flag = false; }
{
    cases = Cases_List() ( def = Default_Case() { flag = true; } )?             {
                                                                                    if (flag)
                                                                                        cases.addChildren(def);
                                                                                    return cases;
                                                                                }
}

Node Cases_List() :
{ Node casesNode = new Node("cases_list"); Node single; }
{
    ( single = Single_Case() { casesNode.addChildren(single); } )+              { return casesNode; }
}

Node Single_Case() :
{ Token c; Node exp; Node sentences = new Node("sentences"); Node sentence; }
{
    c = <CASE_KEYWORD> exp = First_Expression() <COLON>
    ( sentence = Sentence() { sentences.addChildren(sentence); } )*             {
                                                                                    Node single = new Node("case", c.beginLine, c.beginColumn, null);
                                                                                    Node condition = new Node("value");
                                                                                    condition.addChildren(exp);
                                                                                    single.addChildren(condition);
                                                                                    single.addChildren(sentences);
                                                                                    return single;
                                                                                }
}

Node Default_Case() : 
{ Token d; Node sentences = new Node("sentences"); Node sentence; }
{
    d = <DEFAULT_KEYWORD> <COLON>
    ( sentence = Sentence() { sentences.addChildren(sentence); } )*             {
                                                                                    Node defaultNode = new Node("default", d.beginLine, d.beginColumn, null);
                                                                                    defaultNode.addChildren(sentences);
                                                                                    return defaultNode;
                                                                                }
}

Node While() : 
{ Token w; Node exp; Node actions; }
{
    w = <WHILE_KEYWORD> <OPENING_P>
    exp = First_Expression() <CLOSING_P>
    actions = Sentences_Block()                     {
                                                        Node whileNode = new Node("while sentence", w.beginLine, w.beginColumn, null);
                                                        Node condition = new Node("condition");
                                                        condition.addChildren(exp);
                                                        whileNode.addChildren(condition);
                                                        whileNode.addChildren(actions);
                                                        return whileNode;
                                                    }
}

Node Do_While() :
{ Token d; Node actions; Node exp; }
{
    d = <DO_KEYWORD> actions = Sentences_Block()
    <WHILE_KEYWORD> <OPENING_P> 
    exp = First_Expression() <CLOSING_P>                {
                                                            Node doNode = new Node("do while sentence", d.beginLine, d.beginColumn, null);
                                                            Node condition = new Node("condition");
                                                            condition.addChildren(exp);
                                                            doNode.addChildren(actions);
                                                            doNode.addChildren(condition);
                                                            return doNode;
                                                        }
}

