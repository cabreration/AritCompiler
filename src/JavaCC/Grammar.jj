options {
    IGNORE_CASE = true;
    STATIC = false;
}

PARSER_BEGIN(Grammar)
package JavaCC; 
import APIServices.Node;

public class Grammar {}

PARSER_END(Grammar)

/* Scanner */

/* characters that i need to avoid */

SKIP : {
        " "
    |   "\t"
    |   "\r"
    |   "\f"
    |   "\n"
    |   < "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
    |   "#*": MULTILINE_COMMENT
}

/* comments that take more than one line */

<MULTILINE_COMMENT> SKIP:
{
    "*#" : DEFAULT
}

<MULTILINE_COMMENT> MORE:
{
    < ~[] >
}

/* Reserved words and symbols */

TOKEN: {
        <MOD: "%%" >
    |   <EQUALS: "==" >
    |   <NOT_EQUALS: "!=" >
    |   <GREATER_EQUALS: ">=" >
    |   <LESSER_EQUALS: "<=" >
    |   <ARROW: "=>" >
    |   <VALUE_ASIGNMENT: "=" >
    |   <OPENING_P: "(" >
    |   <CLOSING_P: ")" >
    |   <OPENING_B: "[" >
    |   <CLOSING_B: "]" >
    |   <OPENING_C: "{" >
    |   <CLOSING_C: "}" >
    |   <COMMA: "," >
    |   <SEMICOLON: ";" >
    |   <PLUS: "+" >
    |   <MINUS: "-" >
    |   <TIMES: "*" >
    |   <DIV: "/" >
    |   <POWER: "^" >
    |   <GREATER: ">" >
    |   <LESSER: "<" >
    |   <NOT: "!" >
    |   <AND: "&" >
    |   <OR: "|" >
    |   <TERNARY: "?" >
    |   <COLON: ":" >
    |   <IF_KEYWORD: "if" >
    |   <ELSE_KEYWORD: "else" >
    |   <SWITCH_KEYWORD: "switch" >
    |   <CASE_KEYWORD: "case" >
    |   <BREAK_KEYWORD: "break" >
    |   <WHILE_KEYWORD: "while" >
    |   <DO_KEYWORD: "do" >
    |   <FOR_KEYWORD: "for" >
    |   <IN_KEYWORD: "in" >
    |   <CONTINUE_KEYWORD: "continue" >
    |   <RETURN_KEYWORD: "return" >
    |   <FUNCTION_KEYWORD: "function" >
    |   <DEFAULT_KEYWORD: "default" >
    |   <NULL_VALUE: "null" >
    |   <FALSE_VALUE: "false" >
    |   <TRUE_VALUE: "true" >
}

/* tokens that need a regular expression */

TOKEN: {
        <#DIGIT: ["0"-"9"] >
    |   <FRACTIONAL_DIGITS: "." ( <DIGIT> )+ >
    |   <NUMBER_VALUE: ( <DIGIT> )+ | ( <DIGIT> )+ <FRACTIONAL_DIGITS> >
    |   <STRING_VALUE: "\"" (~["\""])* "\"" >
    |   <#LETTER: ["a" - "z", "A" - "Z", "ñ", "Ñ"] >
    |   <IDENTIFIER: <LETTER> ( <LETTER> | <DIGIT> | "." | "_")* | "." (( <LETTER> | "." | "_" ) ( <LETTER> | "." | "_" | <DIGIT> )*)? >
}

/* Scanner End */

Node Root() :
{ Node root = new Node("root"); Node sentences = new Node("sentences"); Node aux; }
{
        ( aux = Sentence() { sentences.addChildren(aux); } )* <EOF> { root.addChildren(sentences); return root; }
}


Node Sentences_Block() : 
{ Node instruction; Node sentences = new Node("sentences"); }
{
    <OPENING_C> ( instruction = Sentence() { sentences.addChildren(instruction); } )* <CLOSING_C> { return sentences; }
}


Node Sentence() :
{ Node instruction; }
{
    instruction = Asignment() ( <SEMICOLON> )? { return instruction; }
}

Node First_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Third_Expression() exp = PFirst_Expression(exp1)
    { return exp; }
}

Node PFirst_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <VALUE_ASIGNMENT> exp1 = Third_Expression() { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("=", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PFirst_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Third_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Fourth_Expression() exp = PThird_Expression(exp1)
    { return exp; }
}

Node PThird_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <OR> exp1 = Fourth_Expression()     { 
                                                bin = new Node("binary expression");
                                                op = new Node("|", v.beginLine, v.beginColumn, null);
                                                op.addChildren(inherited);
                                            }   res = PThird_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Fourth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Fifth_Expression() exp = PFourth_Expression(exp1)
    { return exp; }
}

Node PFourth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
    v = <AND> exp1 = Fifth_Expression() { 
                                            bin = new Node("binary expression");
                                            op = new Node("&", v.beginLine, v.beginColumn, null);
                                            op.addChildren(inherited);
                                        }   res = PFourth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Fifth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Sixth_Expression() exp = PFifth_Expression(exp1)
    { return exp; }
}

Node PFifth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <EQUALS> exp1 = Sixth_Expression()  { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("==", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PFifth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <NOT_EQUALS> exp1 = Sixth_Expression()  { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("!=", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PFifth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Sixth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Seventh_Expression() exp = PSixth_Expression(exp1)
    { return exp; }
}

Node PSixth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <LESSER> exp1 = Seventh_Expression()    { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("<", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <GREATER> exp1 = Seventh_Expression()   { 
                                                        bin = new Node("binary expression");
                                                        op = new Node(">", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <LESSER_EQUALS> exp1 = Seventh_Expression()     { 
                                                                bin = new Node("binary expression");
                                                                op = new Node("<=", v.beginLine, v.beginColumn, null);
                                                                op.addChildren(inherited);
                                                            }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <GREATER_EQUALS> exp1 = Seventh_Expression()    { 
                                                                bin = new Node("binary expression");
                                                                op = new Node(">=", v.beginLine, v.beginColumn, null);
                                                                op.addChildren(inherited);
                                                            }   res = PSixth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Seventh_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Eigth_Expression() exp = PSeventh_Expression(exp1)
    { return exp; }
}

Node PSeventh_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <PLUS> exp1 = Eigth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("+", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PSeventh_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <MINUS> exp1 = Eigth_Expression()       { 
                                                        bin = new Node("binary expression");
                                                        op = new Node("-", v.beginLine, v.beginColumn, null);
                                                        op.addChildren(inherited);
                                                    }   res = PSeventh_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}

Node Eigth_Expression() : 
{ Node exp1; Node exp; }
{
    exp1 = Nineth_Expression() exp = PEigth_Expression(exp1)
    { return exp; }
}

Node PEigth_Expression(Node inherited) : 
{ Node exp1; Node op; Token v; Node res; Node bin; }
{
        v = <TIMES> exp1 = Nineth_Expression()  { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("*", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <DIV> exp1 = Nineth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("/", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        v = <MOD> exp1 = Nineth_Expression()    { 
                                                    bin = new Node("binary expression");
                                                    op = new Node("%%", v.beginLine, v.beginColumn, null);
                                                    op.addChildren(inherited);
                                                }   res = PEigth_Expression(exp1) { op.addChildren(res); bin.addChildren(op); return bin; }
    |
        { return inherited; }
}



Node Nineth_Expression() :
{ Node res; Node min; Token t; Node exp; }
{
        t = <MINUS> exp = Nineth_Expression()   {   
                                                    res = new Node("unary expression");
                                                    min = new Node("-", t.beginLine, t.beginColumn, null); 
                                                    min.addChildren(exp);
                                                    res.addChildren(min);
                                                    return res;
                                                }
    |
        t = <NOT> exp = Nineth_Expression()     {   
                                                    res = new Node("unary expression");
                                                    min = new Node("!", t.beginLine, t.beginColumn, null); 
                                                    min.addChildren(exp);
                                                    res.addChildren(min);
                                                    return res;
                                                }
    |
        res = Value() { return res; }
}

Node Value() :
{ Node aux; Token tok; }
{
        tok = <NULL_VALUE>                                          { return new Node("null value", tok.beginLine, tok.beginColumn, null); }
    |
        tok = <FALSE_VALUE>                                         { return new Node("bool value", tok.beginLine, tok.beginColumn, false); }
    | 
        tok = <TRUE_VALUE>                                          { return new Node("bool value", tok.beginLine, tok.beginColumn, true); }
    |
        tok = <NUMBER_VALUE>                                        { return new Node("number value", tok.beginLine, tok.beginColumn, Double.parseDouble(tok.image)); }
    |
        tok = <STRING_VALUE>                                        { return new Node("string value", tok.beginLine, tok.beginColumn, tok.image); }
    |
        tok = <IDENTIFIER>                                          { return new Node("identifier", tok.beginLine, tok.beginColumn, tok.image); }
    |
        <OPENING_P> aux = First_Expression() <CLOSING_P>            { return aux; }
}

Node Asignment() :
{ Token id;  Node exp; Node param; Node params = new Node("parameters"); Node ident; Node res; Node sent; }
{
        id = <IDENTIFIER> <VALUE_ASIGNMENT> exp = First_Expression()            { 
                                                                                    res = new Node("asignment");
                                                                                    ident = new Node("identifier", id.beginLine, id.beginColumn, id.image);
                                                                                    res.addChildren(ident);
                                                                                    res.addChildren(exp);
                                                                                    return res;
                                                                                }
    |
        LOOKAHEAD(3)
        id = <IDENTIFIER> <VALUE_ASIGNMENT> <FUNCTION_KEYWORD>
         <OPENING_P> ( param = Parameter() { params.addChildren(param); } )* 
         <CLOSING_P> sent = Sentences_Block()                                   {
                                                                                    res = new Node("function");
                                                                                    ident = new Node("identifier", id.beginLine, id.beginColumn, id.image);
                                                                                    res.addChildren(ident);
                                                                                    res.addChildren(params);
                                                                                    res.addChildren(sent);
                                                                                    return res;
                                                                                }
}

Node Parameter() : 
{ Token tok; Node res; Node id; Node exp; }
{
        tok = <IDENTIFIER>                                                      { return new Node("identifier", tok.beginLine, tok.beginColumn, tok.image); }
    |
        LOOKAHEAD(2)
        tok = <IDENTIFIER> <VALUE_ASIGNMENT> exp = First_Expression()           { 
                                                                                    res = new Node("asignment"); 
                                                                                    id = new Node("identifier", tok.beginLine, tok.beginColumn, tok.image);
                                                                                    res.addChildren(id);
                                                                                    res.addChildren(exp);
                                                                                    return res;
                                                                                }
}
