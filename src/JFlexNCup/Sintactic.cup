package JFlexNCup;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import APIServices.Node;

parser code 
{:

    public Node root;

    public void syntax_error(Symbol s)
    {   
        System.out.println("LLegue a un error");
        System.out.println(String.valueOf(s));
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {    
        System.out.println("El error es " + s.value.toString());
        /*if (s == null) 
        {
            errores.add(new ErrorC("Error Sintactico", "null", 0, 0, "ultimo token de finalizacion perdido"));
            System.out.println("Gramatica irreducible");
            return;
        } 
        
        String lexema = s.value.toString();
        int fila = s.right + 1;
        int columna = s.left + 1;
       
        errores.add(new ErrorC("Error Sintactico", lexema, fila, columna, "Error No Recuperable"));*/
    }

:}


action code 
{: 
    public void transferChildren(Node losing, Node gaining) {
        int size = losing.getChildrenCount();
        for (int i = 0; i < size; i++) {
            gaining.addChildren(losing.getChildAt(i));
        }
    }
:}

terminal mod, equals, notEquals, greaterEquals, lesserEquals, arrowFunction, valAsignment, openingPar, closingPar;
terminal openingBracket, closingBracket, openingCurly, closingCurly, comma, semicolon, plus, minus, times, div, power;
terminal greater, lesser, not, and, or, ternary, colon, ifKeyword, elseKeyword, switchKeyword, caseKeyword, breakKeyword;
terminal whileKeyword, doKeyword, forKeyword, inKeyword, continueKeyword, returnKeyword, functionKeyword, defaultKeyword;
terminal nullValue, stringValue, numberValue, falseValue, trueValue, id;

non terminal Node ROOT, ASIGNMENT, TERNARY_EXPRESSION, LOGICAL_EXPRESSION, COMPARATIVE_EXPRESSION, BASIC_EXPRESSION;
non terminal Node BASIC_VALUE, SENTENCES_BLOCK, SENTENCES_LIST, SENTENCE, IF_SENTENCE, ELSE_SENTENCE, SWITCH_SENTENCE, SWITCH_BODY;
non terminal Node CASES_LIST, DEFAULT_CASE, SINGLE_CASE, WHILE_SENTENCE, DOWHILE_SENTENCE, FOR_SENTENCE, BREAK_SENTENCE;
non terminal Node CONTINUE_SENTENCE, RETURN_SENTENCE, FUNCTION_DECL, VECTOR_ACCESS, ADDRESSES, ADDRESS, PARAMETERS_DECL, PARAMETER;
non terminal Node FUNCTION_CALL, EXPRESSIONS_LIST, ASIGNMENT_OPTIONS, MATRIX_ACCESS, MATRIX_ADDRESS, PARAMS;

non terminal BASIC_OPERATOR, RELATIONAL_OPERATOR; 

precedence right valAsignment;
precedence right ternary, colon;
precedence left or;
precedence left and;
precedence left equals, notEquals;
precedence nonassoc lesser, lesserEquals, greater, greaterEquals;
precedence left plus, minus;
precedence left times, div, mod;
precedence left power;
precedence right minus, not;
precedence left openingBracket, closingBracket;

start with ROOT
;

ROOT ::= SENTENCES_LIST:root    {: Node rut = new Node("root"); 
                                   rut.addChildren(root);
                                   parser.root = rut;
                                   System.out.println("Si estoy llegando a la raiz");
                                   RESULT = rut;
                                :}
;

SENTENCES_LIST ::= SENTENCES_LIST:sent SENTENCE:sent2           {: Node sentences = new Node("sentences"); 
                                                                   transferChildren(sent, sentences); 
                                                                   sentences.addChildren(sent2);
                                                                   RESULT = sentences; 
                                                                :}

    | SENTENCE:sent                                             {: Node sentences = new Node("sentences"); 
                                                                   sentences.addChildren(sent);
                                                                   RESULT = sentences;
                                                                :}
;

SENTENCE ::= ASIGNMENT:sent                         {: RESULT = sent; :}

    | FUNCTION_CALL:sent                            {: RESULT = sent; :}

    | IF_SENTENCE:sent                              {: RESULT = sent; :}

    | SWITCH_SENTENCE:sent                          {: RESULT = sent; :}

    | WHILE_SENTENCE:sent                           {: RESULT = sent; :}

    | DOWHILE_SENTENCE:sent                         {: RESULT = sent; :}

    | FOR_SENTENCE:sent                             {: RESULT = sent; :}

    | RETURN_SENTENCE:sent                          {: RESULT = sent; :}

    | BREAK_SENTENCE:sent                           {: RESULT = sent; :}

    | CONTINUE_SENTENCE:sent                        {: RESULT = sent; :}

    | FUNCTION_DECL:sent                            {: RESULT = sent; :}
;

SENTENCES_BLOCK ::= openingCurly SENTENCES_LIST:sent closingCurly         {: RESULT = sent; :}
;

ASIGNMENT ::= ASIGNMENT_OPTIONS:opt valAsignment:v TERNARY_EXPRESSION:value semicolon         {: Node asig = new Node("asignment");
                                                                                                 asig.addChildren(opt);
                                                                                                 asig.addChildren(new Node("=", vright, vleft, null));
                                                                                                 asig.addChildren(value);
                                                                                                 RESULT = asig;
                                                                                              :}

    | ASIGNMENT_OPTIONS:opt valAsignment:v TERNARY_EXPRESSION:value                           {: Node asig = new Node("asignment", optright, optleft, null);
                                                                                                 asig.addChildren(opt);
                                                                                                 asig.addChildren(new Node("=", vright, vleft, null));
                                                                                                 asig.addChildren(value);
                                                                                                 RESULT = asig; 
                                                                                              :}
;

ASIGNMENT_OPTIONS ::= id:id                                     {: Node opt = new Node("asignment option");
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   opt.addChildren(ident);
                                                                   RESULT = opt;    
                                                                :}

    | id:id ADDRESSES:add                                       {: Node opt = new Node("asignment option");
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   opt.addChildren(ident);
                                                                   opt.addChildren(add);
                                                                   RESULT = opt; 
                                                                :}

    | id:id MATRIX_ADDRESS:mat                                  {: Node opt = new Node("asignment option"); 
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   opt.addChildren(ident);
                                                                   opt.addChildren(mat); 
                                                                   RESULT = opt;
                                                                :}                                                            
;

TERNARY_EXPRESSION ::= TERNARY_EXPRESSION:exp1 ternary:ter TERNARY_EXPRESSION:exp2 colon:col TERNARY_EXPRESSION:exp3  {: Node res = new Node("ternary expression");
                                                                                                                         Node tern = new Node("?", terright, terleft, null);
                                                                                                                         tern.addChildren(exp1);
                                                                                                                         Node colon = new Node(":", colright, colleft, null);
                                                                                                                         colon.addChildren(exp2); 
                                                                                                                         colon.addChildren(exp3);
                                                                                                                         res.addChildren(tern);
                                                                                                                         res.addChildren(colon);
                                                                                                                         RESULT = res; 
                                                                                                                       :}

    | LOGICAL_EXPRESSION:log                                                                                      {: RESULT = log; :}                                                                                        
;

LOGICAL_EXPRESSION ::= LOGICAL_EXPRESSION:log1 and:con LOGICAL_EXPRESSION:log2        {: Node res = new Node("logical expression"); 
                                                                                         Node andy = new Node("&", conright, conleft, null);
                                                                                         andy.addChildren(log1); 
                                                                                         andy.addChildren(log2);
                                                                                         res.addChildren(andy);
                                                                                         RESULT = res; 
                                                                                      :}

    | LOGICAL_EXPRESSION:log1 or:dis LOGICAL_EXPRESSION:log2                          {: Node res = new Node("logical expression"); 
                                                                                         Node oro = new Node("|", disright, disleft, null);
                                                                                         oro.addChildren(log1); 
                                                                                         oro.addChildren(log2);
                                                                                         res.addChildren(oro);
                                                                                         RESULT = res; 
                                                                                      :}
                                                                                            
    | not:neg LOGICAL_EXPRESSION:log                                                  {: Node res = new Node("logical expression");
                                                                                         Node no = new Node("!", negright, negleft, null);
                                                                                         no.addChildren(log);
                                                                                         res.addChildren(no);
                                                                                         RESULT = res; 
                                                                                      :}
                                                                                            
    | COMPARATIVE_EXPRESSION:comp                                                     {: RESULT = comp; :}
;

COMPARATIVE_EXPRESSION ::= COMPARATIVE_EXPRESSION:exp1 RELATIONAL_OPERATOR:op COMPARATIVE_EXPRESSION:exp2     {: Node res = new Node("relational expression");
                                                                                                                 Node exp = new Node(String.valueOf(op), opright, opleft, null);
                                                                                                                 exp.addChildren(exp1); 
                                                                                                                 exp.addChildren(exp2);
                                                                                                                 res.addChildren(exp);
                                                                                                                 RESULT = res; 
                                                                                                              :}

    | BASIC_EXPRESSION:basic                                                                                  {: RESULT = basic; :}
;

RELATIONAL_OPERATOR ::= equals  {: RESULT = "=="; :}

    | notEquals                 {: RESULT = "!="; :}

    | greater                   {: RESULT = ">"; :}

    | greaterEquals             {: RESULT = ">="; :}

    | lesser                    {: RESULT = "<"; :}

    | lesserEquals              {: RESULT = "<="; :}
;

BASIC_EXPRESSION ::= BASIC_EXPRESSION:exp1 BASIC_OPERATOR:op BASIC_EXPRESSION:exp2        {: Node res = new Node("basic expression");
                                                                                             Node exp = new Node(String.valueOf(op), opright, opleft, null);
                                                                                             exp.addChildren(exp1); 
                                                                                             exp.addChildren(exp2);
                                                                                             res.addChildren(exp);
                                                                                             RESULT = res; 
                                                                                          :}

    | minus:min TERNARY_EXPRESSION:exp                                                    {: Node res = new Node("basic expression");
                                                                                             Node minus = new Node("-", minright, minleft, null);
                                                                                             minus.addChildren(exp);
                                                                                             res.addChildren(minus);
                                                                                             RESULT = res; 
                                                                                          :}

    | openingPar TERNARY_EXPRESSION:exp closingPar                                        {: RESULT = exp; :}

    | BASIC_VALUE:basic                                                                   {: RESULT = basic; :}

    | id:fier                                                                             {: RESULT = new Node("identifier", fierright, fierleft, String.valueOf(fier)); :}

    | id:fire openingPar closingPar                                                       {: Node call = new Node("call");
                                                                                             call.addChildren(new Node("identifier", fireright, fireleft, String.valueOf(fire)));
                                                                                             RESULT = call; :}
    
    | id:fire openingPar EXPRESSIONS_LIST:params closingPar                               {: Node call = new Node("call"); 
                                                                                             Node ident = new Node("identifier", fireright, fireleft, String.valueOf(fire)); 
                                                                                             call.addChildren(ident); 
                                                                                             call.addChildren(params);
                                                                                             RESULT = call; 
                                                                                          :}
    
    | VECTOR_ACCESS:vec                                                                   {: RESULT = vec; :}                                                                     
    
    | MATRIX_ACCESS:mat                                                                   {: RESULT = mat; :}
;

BASIC_OPERATOR ::= plus {: RESULT = "+"; :}

    | minus             {: RESULT = "-"; :}

    | times             {: RESULT = "*"; :}

    | div               {: RESULT = "/"; :}

    | mod               {: RESULT = "%"; :}

    | power             {: RESULT = "^"; :}

    | valAsignment      {: RESULT = "="; :}
;

BASIC_VALUE ::= nullValue:nuv   {: RESULT = new Node("basic value", nuvright, nuvleft, null); :}

    | stringValue:sv            {: RESULT = new Node("basic value", svright, svleft, String.valueOf(sv)); :}

    | numberValue:nv            {: RESULT = new Node("basic value", nvright, nvleft, Integer.parseInt(String.valueOf(nv))); :}

    | falseValue:fv             {: RESULT = new Node("basic value", fvright, fvleft, false); :}

    | trueValue:tv              {: RESULT = new Node("basic value", tvright, tvleft, true); :}
;

FUNCTION_CALL ::= id:id openingPar closingPar                                   {: Node call = new Node("call"); 
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                   call.addChildren(ident); 
                                                                                   RESULT = call; 
                                                                                :}

    | id:id openingPar closingPar semicolon                                     {: Node call = new Node("call"); 
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                   call.addChildren(ident); 
                                                                                   RESULT = call; 
                                                                                :}

    | id:id openingPar EXPRESSIONS_LIST:params closingPar                       {: Node call = new Node("call"); 
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                   call.addChildren(ident); 
                                                                                   call.addChildren(params);
                                                                                   RESULT = call; 
                                                                                :}

    | id:id openingPar EXPRESSIONS_LIST:params closingPar semicolon             {: Node call = new Node("call"); 
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                   call.addChildren(ident); 
                                                                                   call.addChildren(params);
                                                                                   RESULT = call; 
                                                                                :}
;

EXPRESSIONS_LIST ::= EXPRESSIONS_LIST:list comma PARAMS:param                   {: Node params = new Node("params"); 
                                                                                   transferChildren(list, params);
                                                                                   params.addChildren(param);
                                                                                   RESULT = params; 
                                                                                :}                   

    | PARAMS:param                                                              {: Node params = new Node("params");
                                                                                   params.addChildren(param);
                                                                                   RESULT = params;
                                                                                :}
;

PARAMS ::= defaultKeyword:def               {: System.out.println("default"); RESULT = new Node("default", defright, defleft, null); :}

    | TERNARY_EXPRESSION:exp                {: RESULT = exp; :}
;

IF_SENTENCE ::= ifKeyword openingPar TERNARY_EXPRESSION:cond closingPar SENTENCES_BLOCK:sentences                {: Node ifNode = new Node("if sentence");
                                                                                                                    ifNode.addChildren(cond); 
                                                                                                                    ifNode.addChildren(sentences); 
                                                                                                                    RESULT = ifNode; 
                                                                                                                 :}

    | ifKeyword openingPar TERNARY_EXPRESSION:cond closingPar SENTENCES_BLOCK:sentences ELSE_SENTENCE:elseNode       {: Node ifNode = new Node("if sentence"); 
                                                                                                                        ifNode.addChildren(cond); 
                                                                                                                        ifNode.addChildren(sentences); 
                                                                                                                        ifNode.addChildren(elseNode); 
                                                                                                                        RESULT = ifNode; 
                                                                                                                     :}
;

ELSE_SENTENCE ::= elseKeyword SENTENCES_BLOCK:sentences                    {: Node elseNode = new Node("else sentence"); 
                                                                              elseNode.addChildren(sentences);
                                                                              RESULT = elseNode; 
                                                                           :}

    | elseKeyword IF_SENTENCE:ifSentences                                  {: Node elseNode = new Node("else if sentence");
                                                                              transferChildren(ifSentences, elseNode);
                                                                              RESULT = elseNode; 
                                                                           :}
;

SWITCH_SENTENCE ::= switchKeyword openingPar TERNARY_EXPRESSION:val closingPar openingCurly SWITCH_BODY:body closingCurly  {: Node switchNode = new Node("switch sentence"); 
                                                                                                                              switchNode.addChildren(val); 
                                                                                                                              switchNode.addChildren(body); 
                                                                                                                              RESULT = switchNode; 
                                                                                                                           :}
;

SWITCH_BODY ::= CASES_LIST:cases                {: RESULT = cases; :}

    | CASES_LIST:cases DEFAULT_CASE:def         {: cases.addChildren(def);
                                                   RESULT = cases;
                                                :}
;

CASES_LIST ::= CASES_LIST:cases SINGLE_CASE:single              {: Node casesNode = new Node("cases_list"); 
                                                                   transferChildren(cases, casesNode); 
                                                                   casesNode.addChildren(single);
                                                                   RESULT = casesNode;
                                                                :}

    | SINGLE_CASE:single                                        {: Node situation = new Node("cases_list");
                                                                   situation.addChildren(single);
                                                                   RESULT = situation;
                                                                :}
;

SINGLE_CASE ::= caseKeyword TERNARY_EXPRESSION:exp colon SENTENCES_LIST:actions     {: Node single = new Node("case");
                                                                                       single.addChildren(exp); 
                                                                                       single.addChildren(actions);
                                                                                       RESULT = single;
                                                                                    :}
;

DEFAULT_CASE ::= defaultKeyword colon SENTENCES_LIST:actions                        {: Node defa = new Node("default"); 
                                                                                       defa.addChildren(actions); 
                                                                                       RESULT = defa;
                                                                                    :}
;

WHILE_SENTENCE ::= whileKeyword openingPar TERNARY_EXPRESSION:exp closingPar SENTENCES_BLOCK:actions      {: Node whileNode = new Node("while sentence"); 
                                                                                                             whileNode.addChildren(exp); 
                                                                                                             whileNode.addChildren(actions);
                                                                                                             RESULT = whileNode;
                                                                                                          :}
;

DOWHILE_SENTENCE ::= doKeyword SENTENCES_BLOCK:actions whileKeyword openingPar TERNARY_EXPRESSION:exp closingPar     {: Node doNode = new Node("do while sentence"); 
                                                                                                                        doNode.addChildren(actions); 
                                                                                                                        doNode.addChildren(exp); 
                                                                                                                        RESULT = doNode;
                                                                                                                      :}

    | doKeyword SENTENCES_BLOCK:actions whileKeyword openingPar TERNARY_EXPRESSION:exp closingPar semicolon          {: Node doNode = new Node("do while sentence"); 
                                                                                                                        doNode.addChildren(actions); 
                                                                                                                        doNode.addChildren(exp); 
                                                                                                                        RESULT = doNode; 
                                                                                                                     :}
;

FOR_SENTENCE ::= forKeyword openingPar id:id inKeyword TERNARY_EXPRESSION:exp closingPar SENTENCES_BLOCK:actions      {: Node forNode = new Node("for sentence"); 
                                                                                                                         Node idNode = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                         forNode.addChildren(idNode);
                                                                                                                         forNode.addChildren(exp);
                                                                                                                         forNode.addChildren(actions);
                                                                                                                         RESULT = forNode;
                                                                                                                      :}
;

RETURN_SENTENCE ::= returnKeyword                                               {: RESULT = new Node("return sentence"); :}

    | returnKeyword semicolon                                                   {: RESULT = new Node("return sentence"); :}

    | returnKeyword openingPar TERNARY_EXPRESSION:exp closingPar                {: Node retNode = new Node("return sentence"); 
                                                                                   retNode.addChildren(exp);
                                                                                   RESULT = retNode;
                                                                                 :}

    | returnKeyword openingPar TERNARY_EXPRESSION:exp closingPar semicolon      {: Node retNode = new Node("return sentence"); 
                                                                                   retNode.addChildren(exp); 
                                                                                   RESULT = retNode; 
                                                                                :}
;

BREAK_SENTENCE ::=  breakKeyword                    {: RESULT = new Node("break sentence"); :}

    | breakKeyword semicolon                        {: RESULT = new Node("break sentence"); :}
;

CONTINUE_SENTENCE ::= continueKeyword               {: RESULT = new Node("continue sentence"); :}

    | continueKeyword semicolon                     {: RESULT = new Node("continue sentence"); :}
;

FUNCTION_DECL ::= id:id valAsignment functionKeyword openingPar closingPar SENTENCES_BLOCK:actions                  {: Node fun = new Node("function declaration"); 
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}

    | id:id valAsignment functionKeyword openingPar PARAMETERS_DECL:params closingPar SENTENCES_BLOCK:actions       {: Node fun = new Node("function declaration"); 
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(params);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}

    | id:id valAsignment openingPar closingPar arrowFunction SENTENCES_BLOCK:actions                                {: Node fun = new Node("function declaration"); 
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}

    | id:id valAsignment openingPar PARAMETERS_DECL:params closingPar arrowFunction SENTENCES_BLOCK:actions         {: Node fun = new Node("function declaration"); 
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id)); 
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(params);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}
;

PARAMETERS_DECL ::= PARAMETERS_DECL:ters comma PARAMETER:par                    {: Node params = new Node("paratemers"); 
                                                                                   transferChildren(ters, params); 
                                                                                   params.addChildren(par); 
                                                                                   RESULT = params; 
                                                                                :}

    | PARAMETER:par                                                             {: Node params = new Node("parameters");
                                                                                   params.addChildren(par);
                                                                                   RESULT = params; :}                      
;

PARAMETER ::= id:id                 {: RESULT = new Node("identifier", idright, idleft, String.valueOf(id)); :}

    | ASIGNMENT:asig                {: RESULT = asig; :}
;

ADDRESSES ::= ADDRESSES:addresses ADDRESS:single                {: Node adds = new Node("addresses"); 
                                                                   transferChildren(addresses, adds);
                                                                   adds.addChildren(single);
                                                                   RESULT = adds;
                                                                :}

    | ADDRESS:single                                            {: Node adds = new Node("addresses"); 
                                                                   adds.addChildren(single);
                                                                   RESULT = adds;
                                                                :}
;

ADDRESS ::= openingBracket TERNARY_EXPRESSION:exp closingBracket                                {: Node address = new Node("address", 0, 0, "singleB"); 
                                                                                                   address.addChildren(exp);
                                                                                                   RESULT = address; 
                                                                                                :}

    | openingBracket openingBracket TERNARY_EXPRESSION:exp closingBracket closingBracket        {: Node address = new Node("address", 0, 0, "doubleB"); 
                                                                                                   address.addChildren(exp);
                                                                                                   RESULT = address; 
                                                                                                :}            
;

MATRIX_ACCESS ::= id:id MATRIX_ADDRESS:mat                      {: Node access = new Node("matrix"); 
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   access.addChildren(ident);
                                                                   access.addChildren(mat);
                                                                   RESULT = access; 
                                                                :}
;

MATRIX_ADDRESS ::= openingBracket TERNARY_EXPRESSION:exp1 comma:c TERNARY_EXPRESSION:exp2 closingBracket        {: Node address = new Node("matrix_address", 0, 0, "doubleM");
                                                                                                                   address.addChildren(exp1);
                                                                                                                   address.addChildren(exp2); 
                                                                                                                   RESULT = address; 
                                                                                                                :}

    | openingBracket TERNARY_EXPRESSION:exp comma:c closingBracket                                              {: Node address = new Node("matrix_address", 0, 0, "leftM");
                                                                                                                   address.addChildren(exp);                                                                                                                   
                                                                                                                   RESULT = address; 
                                                                                                                :}

    | openingBracket comma:c TERNARY_EXPRESSION:exp closingBracket                                              {: Node address = new Node("matrix_address", 0, 0, "rightM");
                                                                                                                   address.addChildren(exp);                                                                                                                   
                                                                                                                   RESULT = address; 
                                                                                                                :}
;
