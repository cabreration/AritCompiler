package JFlexNCup;

import java_cup.runtime.Symbol;
import java.util.ArrayList;
import APIServices.Node;
import aritcompiler.Singleton;
import APIServices.CompileError;

parser code
{:

    public Node root;

    public void syntax_error(Symbol s)
    {
        if (s == null) {
            System.err.println("venia vacio");
            return;
        }
        System.err.println(s.value.toString() + " " + s.right + " "+ s.left);
        Singleton.insertError(new CompileError("Sintactico", "No se esperaba el token " + s.value.toString(), s.right, s.left));
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        System.out.println("El error es " + s.value.toString() + " " + s.right + " " + s.left);
        if (s == null)
        {
            Singleton.insertError( new CompileError("Sintactico", "fin de archivo no encontrado", 0, 0));
            System.out.println("Gramatica irreducible");
            return;
        }

        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        System.err.println(lexema + " - " + fila + "  - "+ columna);

        Singleton.insertError(new CompileError("Error Sintactico", "No se esperaba el token " + lexema, fila, columna));
    }

:}


action code
{:
    public void transferChildren(Node losing, Node gaining) {
        int size = losing.getChildrenCount();
        for (int i = 0; i < size; i++) {
            gaining.addChildren(losing.getChildAt(i));
        }
    }

    public Node rearrangeExpression(Node expression) {
        if (expression.getChildAt(0).getChildAt(1).getNodeType().equals("binary expression") 
            && !expression.getChildAt(0).getChildAt(0).getNodeType().equals("binary expression")
            && !expression.getChildAt(0).getChildAt(0).getNodeType().equals("unary expression")) {
            Node ret = expression.getChildAt(0).getChildAt(1);
            expression.getChildAt(0).addChildrenAt(1, ret.getChildAt(0).getChildAt(0));
            expression.getChildAt(0).deleteChildAt(2);
            ret.getChildAt(0).deleteChildAt(0);
            ret.getChildAt(0).addChildrenAt(0, expression);
            return rearrangeExpression(ret);
        }
        return expression;
    }
:}

terminal mod, equals, notEquals, greaterEquals, lesserEquals, arrowFunction, valAsignment, openingPar, closingPar;
terminal openingBracket, closingBracket, openingCurly, closingCurly, comma, semicolon, plus, minus, times, div, power;
terminal greater, lesser, not, and, or, ternary, colon, ifKeyword, elseKeyword, switchKeyword, caseKeyword, breakKeyword;
terminal whileKeyword, doKeyword, forKeyword, inKeyword, continueKeyword, returnKeyword, functionKeyword, defaultKeyword;
terminal nullValue, stringValue, numericValue, falseValue, trueValue, id, integerValue;

non terminal Node ROOT, ASIGNMENT, LONE_EXPRESSION;
non terminal Node SENTENCES_BLOCK, SENTENCES_LIST, SENTENCE, IF_SENTENCE, ELSE_SENTENCE, SWITCH_SENTENCE, SWITCH_BODY;
non terminal Node CASES_LIST, DEFAULT_CASE, SINGLE_CASE, WHILE_SENTENCE, DOWHILE_SENTENCE, FOR_SENTENCE, BREAK_SENTENCE;
non terminal Node CONTINUE_SENTENCE, RETURN_SENTENCE, VECTOR_ACCESS, ADDRESSES, ADDRESS, PARAMETERS_DECL, PARAMETER;
non terminal Node FUNCTION_CALL, EXPRESSIONS_LIST, MATRIX_ACCESS, MATRIX_ADDRESS, PARAMS, ARROW_FUNCTION, VECTORS, EXPRESSION;

precedence right valAsignment;
precedence right ternary, colon;
precedence left or;
precedence left and;
precedence left equals, notEquals;
precedence nonassoc lesser, lesserEquals, greater, greaterEquals;
precedence left plus, minus;
precedence left times, div, mod;
precedence left power;
//precedence right minus, not;
precedence left openingBracket, closingBracket;
precedence nonassoc openingPar, closingPar;

start with ROOT
;

ROOT ::= SENTENCES_LIST:root    {: Node rut = new Node("root");
                                   rut.addChildren(root);
                                   parser.root = rut;
                                   //System.out.println("Si estoy llegando a la raiz");
                                   RESULT = rut;
                                :}

|                               {: Node sentences = new Node("sentences");
                                   Node rut = new Node("root");
                                   rut.addChildren(sentences);
                                   parser.root = rut;
                                   RESULT = rut;
                                :}
;

SENTENCES_LIST ::= SENTENCES_LIST:sent SENTENCE:sent2           {: Node sentences = new Node("sentences");
                                                                   transferChildren(sent, sentences);
                                                                   sentences.addChildren(sent2);
                                                                   RESULT = sentences;
                                                                :}

    | SENTENCE:sent                                             {: Node sentences = new Node("sentences");
                                                                   sentences.addChildren(sent);
                                                                   RESULT = sentences;
                                                                :}
;

SENTENCES_BLOCK ::= openingCurly closingCurly                   {: RESULT = new Node("sentences"); :}

    | openingCurly SENTENCES_LIST:list closingCurly             {: RESULT = list; :}

    | openingCurly error closingCurly                           {: RESULT = new Node("sentences"); :}
;

SENTENCE ::= ASIGNMENT:sent                                 {: RESULT = sent; :}

    | ASIGNMENT:sent semicolon                              {: RESULT = sent; :}

    | FUNCTION_CALL:call                                    {: RESULT = call; :}

    | FUNCTION_CALL:call semicolon                          {: RESULT = call; :}

    | IF_SENTENCE:si                                        {: RESULT = si; :}

    | SWITCH_SENTENCE:sw                                    {: RESULT = sw; :}

    | WHILE_SENTENCE:w                                      {: RESULT = w; :}

    | DOWHILE_SENTENCE:du                                   {: RESULT = du; :}

    | DOWHILE_SENTENCE:du semicolon                         {: RESULT = du; :}

    | FOR_SENTENCE:f                                        {: RESULT = f; :}

    | RETURN_SENTENCE:r                                     {: RESULT = r; :}

    | RETURN_SENTENCE:r semicolon                           {: RESULT = r; :}

    | BREAK_SENTENCE:b                                      {: RESULT = b; :}

    | BREAK_SENTENCE:b semicolon                            {: RESULT = b; :}

    | CONTINUE_SENTENCE:c                                   {: RESULT = c; :}

    | CONTINUE_SENTENCE:c semicolon                         {: RESULT = c; :}

    | error SENTENCE:s                                      {: RESULT = s; :}
; 

LONE_EXPRESSION ::= LONE_EXPRESSION:exp1 ternary:ter LONE_EXPRESSION:exp2 colon:col LONE_EXPRESSION:exp3     {: Node res = new Node("ternary expression");
                                                                                                              Node tern = new Node("?", terright, terleft, null);
                                                                                                              tern.addChildren(exp1);
                                                                                                              Node colon = new Node(":", colright, colleft, null);
                                                                                                              colon.addChildren(exp2);
                                                                                                              colon.addChildren(exp3);
                                                                                                              res.addChildren(tern);
                                                                                                              res.addChildren(colon);
                                                                                                              RESULT = res;
                                                                                                            :}

    | not:op LONE_EXPRESSION:exp                                                    {: Node res = new Node("unary expression");
                                                                                       Node operator = new Node("!", opright, opleft, null);
                                                                                       operator.addChildren(exp);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :} %prec not                                                                                                   

    | LONE_EXPRESSION:exp1 or:op LONE_EXPRESSION:exp2                               {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("|", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 and:op LONE_EXPRESSION:exp2                              {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("&", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 notEquals:op LONE_EXPRESSION:exp2                        {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("!=", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}
    
    | LONE_EXPRESSION:exp1 equals:op LONE_EXPRESSION:exp2                           {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("==", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 greater:op LONE_EXPRESSION:exp2                          {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node(">", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 lesser:op LONE_EXPRESSION:exp2                          {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("<", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :} 
    
    | LONE_EXPRESSION:exp1 greaterEquals:op LONE_EXPRESSION:exp2                    {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node(">=", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}
    
    | LONE_EXPRESSION:exp1 lesserEquals:op LONE_EXPRESSION:exp2                     {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("<=", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}
    
    | LONE_EXPRESSION:exp1 plus:op LONE_EXPRESSION:exp2                             {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("+", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 minus:op LONE_EXPRESSION:exp2                            {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("-", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 times:op LONE_EXPRESSION:exp2                            {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("*", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 div:op LONE_EXPRESSION:exp2                              {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("/", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | LONE_EXPRESSION:exp1 mod:op LONE_EXPRESSION:exp2                              {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("%%", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}
    
    | LONE_EXPRESSION:exp1 power:op LONE_EXPRESSION:exp2                            {: Node res = new Node("binary expression");
                                                                                       Node operator = new Node("^", opright, opleft, null);
                                                                                       operator.addChildren(exp1);
                                                                                       operator.addChildren(exp2);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :}

    | minus:op  LONE_EXPRESSION:exp                                                 {: Node res = new Node("unary expression");
                                                                                       Node operator = new Node("-", opright, opleft, null);
                                                                                       operator.addChildren(exp);
                                                                                       res.addChildren(operator);
                                                                                       RESULT = res;
                                                                                    :} %prec minus

    | openingPar LONE_EXPRESSION:exp closingPar                                     {: RESULT = exp; :}

    | EXPRESSION:exp                                                                {: RESULT = exp; :}
;
    
EXPRESSION ::= FUNCTION_CALL:f                                                      {: RESULT = f; :}

    | VECTOR_ACCESS:st                                                              {: RESULT = st; :}

    | MATRIX_ACCESS:mat                                                             {: RESULT = mat; :}

    | openingPar id:id closingPar arrowFunction SENTENCES_BLOCK:list                {: Node arr = new Node("arrow def");
                                                                                       Node param = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                       Node parameters = new Node("parameters");
                                                                                       parameters.addChildren(param);
                                                                                       arr.addChildren(parameters);
                                                                                       arr.addChildren(list);
                                                                                       RESULT = arr;
                                                                                    :}

    | openingPar id:id valAsignment LONE_EXPRESSION:exp closingPar
        arrowFunction SENTENCES_BLOCK:sent                                          {: Node arr = new Node("arrow def");
                                                                                       Node param = new Node("asignment");
                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                       param.addChildren(ident);
                                                                                       param.addChildren(exp);
                                                                                       Node parameters = new Node("parameters");
                                                                                       parameters.addChildren(param);
                                                                                       arr.addChildren(parameters);
                                                                                       arr.addChildren(sent);
                                                                                       RESULT = arr;
                                                                                    :}

    | nullValue:v                                                                   {: RESULT = new Node("null value", vright, vleft, null); :}

    | stringValue:v                                                                 {: RESULT = new Node("string value", vright, vleft, String.valueOf(v)); :}

    | numericValue:v                                                                {: RESULT = new Node("numeric value", vright, vleft, Double.parseDouble(String.valueOf(v))); :}

    | integerValue:v                                                                {: RESULT = new Node("integer value", vright, vleft, Integer.parseInt(String.valueOf(v))); :}

    | falseValue:v                                                                  {: RESULT = new Node("bool value", vright, vleft, false); :}

    | trueValue:v                                                                   {: RESULT = new Node("bool value", vright, vleft, true); :}

    | id:id                                                                         {: RESULT = new Node("identifier", idright, idleft, String.valueOf(id).toLowerCase()); :}

    | openingPar id:id closingPar                                                   {: RESULT = new Node("identifier", idright, idleft, String.valueOf(id)); :}

    | openingPar id:id valAsignment:v LONE_EXPRESSION:exp closingPar                {: Node res = new Node("binary expression");
                                                                                       Node op = new Node("=", vright, vleft, null);
                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                       op.addChildren(ident);
                                                                                       op.addChildren(exp);
                                                                                       res.addChildren(op);
                                                                                       RESULT = res;
                                                                                    :}
;

ASIGNMENT ::= id:id valAsignment:v LONE_EXPRESSION:exp              {: Node as = new Node("asignment", vright, vleft, null);
                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                       as.addChildren(ident);                                                                     
                                                                       as.addChildren(exp);
                                                                       RESULT = as;
                                                                    :}

    | MATRIX_ACCESS:mat valAsignment:v LONE_EXPRESSION:exp          {: Node as = new Node("matrix asignment", vright, vleft, null);
                                                                       as.addChildren(mat);
                                                                       
                                                                       as.addChildren(exp);
                                                                       RESULT = as;
                                                                    :}

    | VECTOR_ACCESS:vec valAsignment LONE_EXPRESSION:exp            {: Node as = new Node("structure asignment");
                                                                       as.addChildren(vec);
                                                                       
                                                                       as.addChildren(exp);
                                                                       RESULT = as;
                                                                    :}

    | id:id valAsignment:v ARROW_FUNCTION:f                         {: Node as = new Node("arrow function", vright, vleft, null);
                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                       as.addChildren(ident);
                                                                       as.addChildren(f);
                                                                       RESULT = as;
                                                                    :}

    | id:id valAsignment functionKeyword:f openingPar closingPar SENTENCES_BLOCK:actions                            {: Node fun = new Node("function", fright, fleft, null);
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}

    | id:id valAsignment functionKeyword:f openingPar PARAMETERS_DECL:params closingPar SENTENCES_BLOCK:actions     {: Node fun = new Node("function", fright, fleft, null);
                                                                                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                       fun.addChildren(ident);
                                                                                                                       fun.addChildren(params);
                                                                                                                       fun.addChildren(actions);
                                                                                                                       RESULT = fun;
                                                                                                                    :}
;

ARROW_FUNCTION ::= openingPar closingPar arrowFunction SENTENCES_BLOCK:list                                                 {: Node res = new Node("arrow def");
                                                                                                                               res.addChildren(list);
                                                                                                                               RESULT = res;
                                                                                                                            :}

    | openingPar id:id comma PARAMETERS_DECL:params closingPar arrowFunction SENTENCES_BLOCK:list                           {: Node res = new Node("arrow def");
                                                                                                                               Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                               params.addChildrenAt(0, ident);
                                                                                                                               res.addChildren(params);
                                                                                                                               res.addChildren(list);
                                                                                                                               RESULT = res;
                                                                                                                            :}

    | openingPar id:id valAsignment LONE_EXPRESSION:exp comma PARAMETERS_DECL:params closingPar arrowFunction SENTENCES_BLOCK:list       {: Node res = new Node("arrow def");
                                                                                                                                      Node param = new Node("asignment");
                                                                                                                                      Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                                      param.addChildren(ident);
                                                                                                                                      param.addChildren(exp);
                                                                                                                                      
                                                                                                                                      params.addChildrenAt(0, param);
                                                                                                                                      res.addChildren(params);
                                                                                                                                      res.addChildren(list);
                                                                                                                                      RESULT = res;
                                                                                                                                    :}
;

PARAMETERS_DECL ::= PARAMETERS_DECL:ters comma PARAMETER:par                    {: Node params = new Node("paratemers");
                                                                                   transferChildren(ters, params);
                                                                                   params.addChildren(par);
                                                                                   RESULT = params;
                                                                                :}

    | PARAMETER:par                                                             {: Node params = new Node("parameters");
                                                                                   params.addChildren(par);
                                                                                   RESULT = params; :}
;

PARAMETER ::= id:id                                         {: RESULT = new Node("identifier", idright, idleft, String.valueOf(id)); :}

    | id:id valAsignment:v LONE_EXPRESSION:exp              {: Node param = new Node("asignment", vright, vleft, null);
                                                               Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                               param.addChildren(ident);
                                                               
                                                               param.addChildren(exp);
                                                               RESULT = param;
                                                            :}
;

FUNCTION_CALL ::= id:id openingPar closingPar                                   {: Node call = new Node("call");
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                   call.addChildren(ident);
                                                                                   RESULT = call;
                                                                                :}

    | id:id openingPar EXPRESSIONS_LIST:params closingPar                       {: Node call = new Node("call");
                                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                   call.addChildren(ident);
                                                                                   call.addChildren(params);
                                                                                   RESULT = call;
                                                                                :}
;

EXPRESSIONS_LIST ::= EXPRESSIONS_LIST:list comma PARAMS:param                   {: Node params = new Node("params");
                                                                                   transferChildren(list, params);
                                                                                   params.addChildren(param);
                                                                                   RESULT = params;
                                                                                :}

    | PARAMS:param                                                              {: Node params = new Node("params");
                                                                                   params.addChildren(param);
                                                                                   RESULT = params;
                                                                                :}
;

PARAMS ::= defaultKeyword:def               {: RESULT = new Node("default", defright, defleft, null); :}

    | LONE_EXPRESSION:exp                {: RESULT = exp; :}
;

IF_SENTENCE ::= ifKeyword:i openingPar LONE_EXPRESSION:cond closingPar SENTENCES_BLOCK:sentences                {:  Node ifNode = new Node("if sentence", iright, ileft, null);
                                                                                                                    Node condition = new Node("condition");
                                                                                                                    
                                                                                                                    condition.addChildren(cond);
                                                                                                                    ifNode.addChildren(condition);
                                                                                                                    ifNode.addChildren(sentences);
                                                                                                                    RESULT = ifNode;
                                                                                                                 :}

    | ifKeyword:i openingPar LONE_EXPRESSION:cond closingPar SENTENCES_BLOCK:sentences ELSE_SENTENCE:elseNode        {:  Node ifNode = new Node("if sentence", iright, ileft, null);
                                                                                                                        Node condition = new Node("condition");
                                                                                                                        
                                                                                                                        condition.addChildren(cond);
                                                                                                                        ifNode.addChildren(condition);
                                                                                                                        ifNode.addChildren(sentences);
                                                                                                                        ifNode.addChildren(elseNode);
                                                                                                                        RESULT = ifNode;
                                                                                                                     :}
;

ELSE_SENTENCE ::= elseKeyword:e SENTENCES_BLOCK:sentences                  {: Node elseNode = new Node("else sentence", eright, eleft, null);
                                                                              elseNode.addChildren(sentences);
                                                                              RESULT = elseNode;
                                                                           :}

    | elseKeyword:e IF_SENTENCE:ifSentences                                {: Node elseNode = new Node("else if sentence", eright, eleft, null);
                                                                              transferChildren(ifSentences, elseNode);
                                                                              RESULT = elseNode;
                                                                           :}
;

SWITCH_SENTENCE ::= switchKeyword:s openingPar LONE_EXPRESSION:val closingPar openingCurly SWITCH_BODY:body closingCurly      {:  Node switchNode = new Node("switch sentence", sright, sleft, null);
                                                                                                                                Node condition = new Node("condition");
                                                                                                                                
                                                                                                                                condition.addChildren(val);
                                                                                                                                switchNode.addChildren(condition);
                                                                                                                                switchNode.addChildren(body);
                                                                                                                                RESULT = switchNode;
                                                                                                                            :}
;

SWITCH_BODY ::= CASES_LIST:cases                {: RESULT = cases; :}

    | CASES_LIST:cases DEFAULT_CASE:def         {: cases.addChildren(def);
                                                   RESULT = cases;
                                                :}
;

CASES_LIST ::= CASES_LIST:cases SINGLE_CASE:single              {: Node casesNode = new Node("cases_list");
                                                                   transferChildren(cases, casesNode);
                                                                   casesNode.addChildren(single);
                                                                   RESULT = casesNode;
                                                                :}

    | SINGLE_CASE:single                                        {: Node situation = new Node("cases_list");
                                                                   situation.addChildren(single);
                                                                   RESULT = situation;
                                                                :}
;

SINGLE_CASE ::= caseKeyword:c LONE_EXPRESSION:exp colon SENTENCES_LIST:actions      {: Node single = new Node("case", cright, cleft, null);
                                                                                       Node condition = new Node("value");
                                                                                       
                                                                                       condition.addChildren(exp);
                                                                                       single.addChildren(condition);
                                                                                       single.addChildren(actions);
                                                                                       RESULT = single;
                                                                                    :}
;

DEFAULT_CASE ::= defaultKeyword:d colon SENTENCES_LIST:actions                      {: Node defa = new Node("default", dright, dleft, null);
                                                                                       defa.addChildren(actions);
                                                                                       RESULT = defa;
                                                                                    :}
;

WHILE_SENTENCE ::= whileKeyword:w openingPar LONE_EXPRESSION:exp closingPar SENTENCES_BLOCK:actions     {:  Node whileNode = new Node("while sentence", wright, wleft, null);
                                                                                                            Node condition = new Node("condition");
                                                                                                            
                                                                                                            condition.addChildren(exp);
                                                                                                            whileNode.addChildren(condition);
                                                                                                            whileNode.addChildren(actions);
                                                                                                            RESULT = whileNode;
                                                                                                        :}
;

DOWHILE_SENTENCE ::= doKeyword:d SENTENCES_BLOCK:actions whileKeyword openingPar LONE_EXPRESSION:exp closingPar     {:  Node doNode = new Node("do while sentence", dright, dleft, null);
                                                                                                                        Node condition = new Node("condition");
                                                                                                                        
                                                                                                                        condition.addChildren(exp);
                                                                                                                        doNode.addChildren(actions);
                                                                                                                        doNode.addChildren(condition);
                                                                                                                        RESULT = doNode;
                                                                                                                    :}
;

FOR_SENTENCE ::= forKeyword:f openingPar id:id inKeyword LONE_EXPRESSION:exp closingPar SENTENCES_BLOCK:actions     {:  Node forNode = new Node("for sentence", fright, fleft, null);
                                                                                                                        Node idNode = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                                                                        forNode.addChildren(idNode);
                                                                                                                        Node condition = new Node("condition");
                                                                                                                        
                                                                                                                        condition.addChildren(exp);
                                                                                                                        forNode.addChildren(condition);
                                                                                                                        forNode.addChildren(actions);
                                                                                                                        RESULT = forNode;
                                                                                                                    :}
;

RETURN_SENTENCE ::= returnKeyword:r                                               {: RESULT = new Node("return sentence", rright, rleft, null); :}

    | returnKeyword:r openingPar closingPar                                       {: RESULT = new Node("return sentence", rright, rleft, null); :}

    | returnKeyword:r openingPar LONE_EXPRESSION:exp closingPar                   {: Node retNode = new Node("return sentence", rright, rleft, null);
                                                                                     
                                                                                     retNode.addChildren(exp);
                                                                                     RESULT = retNode;
                                                                                  :}
;

BREAK_SENTENCE ::=  breakKeyword:b                    {: RESULT = new Node("break sentence", bright, bleft, null); :}
;

CONTINUE_SENTENCE ::= continueKeyword:b               {: RESULT = new Node("continue sentence", bright, bleft, null); :}
;

VECTOR_ACCESS ::= id:id ADDRESSES:add               {: Node res = new Node("structure access");
                                                       Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                       res.addChildren(ident);
                                                       res.addChildren(add);
                                                       RESULT = res;
                                                    :}
;

ADDRESSES ::= ADDRESSES:addresses ADDRESS:single                {: Node adds = new Node("addresses");
                                                                   transferChildren(addresses, adds);
                                                                   adds.addChildren(single);
                                                                   RESULT = adds;
                                                                :}

    | ADDRESS:single                                            {: Node adds = new Node("addresses");
                                                                   adds.addChildren(single);
                                                                   RESULT = adds;
                                                                :}
;

ADDRESS ::= openingBracket LONE_EXPRESSION:exp closingBracket                                   {: Node address = new Node("address", 0, 0, "singleB");                                                                         
                                                                                                   address.addChildren(exp);
                                                                                                   RESULT = address;
                                                                                                :}

    | openingBracket openingBracket LONE_EXPRESSION:exp closingBracket closingBracket           {: Node address = new Node("address", 0, 0, "doubleB");                                                                        
                                                                                                   address.addChildren(exp);
                                                                                                   RESULT = address;
                                                                                                :}
;

MATRIX_ACCESS ::= id:id MATRIX_ADDRESS:mat                      {: Node access = new Node("matrix access");
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   access.addChildren(ident);
                                                                   access.addChildren(mat);
                                                                   RESULT = access;
                                                                :}

    | id:id MATRIX_ADDRESS:mat VECTORS:vecs                     {: Node access = new Node("matrix access");
                                                                   Node ident = new Node("identifier", idright, idleft, String.valueOf(id));
                                                                   access.addChildren(ident);
                                                                   access.addChildren(mat);
                                                                   access.addChildren(vecs);
                                                                   RESULT = access;
                                                                :}
;

MATRIX_ADDRESS ::= openingBracket LONE_EXPRESSION:exp1 comma:c LONE_EXPRESSION:exp2 closingBracket              {: Node address = new Node("matrix_address", 0, 0, "both");
                                                                                                                   
                                                                                                                   address.addChildren(exp1);
                                                                                                                   address.addChildren(exp2);
                                                                                                                   RESULT = address;
                                                                                                                :}

    | openingBracket LONE_EXPRESSION:exp comma:c closingBracket                                                 {: Node address = new Node("matrix_address", 0, 0, "left");
                                                                                                                   
                                                                                                                   address.addChildren(exp);
                                                                                                                   RESULT = address;
                                                                                                                :}

    | openingBracket comma:c LONE_EXPRESSION:exp closingBracket                                                 {: Node address = new Node("matrix_address", 0, 0, "right");
                                                                                                                   
                                                                                                                   address.addChildren(exp);
                                                                                                                   RESULT = address;
                                                                                                                :}
;

VECTORS ::= VECTORS:addresses openingBracket LONE_EXPRESSION:exp closingBracket                 {: Node adds = new Node("addresses");
                                                                                                   transferChildren(addresses, adds);
                                                                                                   
                                                                                                   adds.addChildren(exp);
                                                                                                   RESULT = adds;
                                                                                                :}

    | openingBracket LONE_EXPRESSION:exp closingBracket                                         {: Node addresses = new Node("addresses");
                                                                                                   
                                                                                                   addresses.addChildren(exp);
                                                                                                   RESULT = addresses;
                                                                                                :}
;
